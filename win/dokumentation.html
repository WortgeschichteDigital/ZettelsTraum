<!doctype html>
<html lang="de">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
		
		<title> </title>
		
		<link rel="stylesheet" href="../css/win/hilfe.css">
		
		<script src="../js/app/helfer.js"></script>
		
		<script src="../js/win/init-dokumentation.js"></script>
		<script src="../js/win/helferWin.js"></script>
		<script src="../js/win/hilfe.js"></script>
	</head>
	<body>
		<!-- KOPF -->
		<header>
			<h1>Technische Dokumentation</h1
				><img src="../img/icon.svg" width="48" height="48" alt="" id="icon">
		</header>
		
		<!-- GRID -->
		<main>
			<nav>
				<p><input type="text" value="" placeholder="Suche" spellcheck="false" id="suchfeld"
					><a href="#" id="suchfeld-lupe"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path transform="translate(4 4)" d="m6.5 1a5.5 5.5 0 0 0-5.5 5.5 5.5 5.5 0 0 0 5.5 5.5 5.5 5.5 0 0 0 3.1172-0.969l3.6618 3.662a1 1 0 0 0 0.721 0.307 1 1 0 0 0 1-1 1 1 0 0 0-0.303-0.717l-3.67-3.6697a5.5 5.5 0 0 0 0.973-3.1133 5.5 5.5 0 0 0-5.5-5.5zm0 2a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5 3.5 3.5 0 0 1-3.5-3.5 3.5 3.5 0 0 1 3.5-3.5z" fill="#212121"/></svg></a></p>
				<ul>
					<li><a href="#" class="link-sektion-framework kopf">Framework</a></li>
					<li><a href="#" class="link-sektion-ordner kopf">Ordner und Dateien</a></li>
					<li><a href="#" class="link-sektion-js kopf">JavaScript</a></li>
					<li><a href="#" class="link-sektion-wgd kopf">WGD-Dateiformat</a></li>
				</ul>
			</nav>
			<div>
				<!-- START -->
				<section id="sektion-start">
					<p class="obacht">Die technische Dokumentation ist nur für diejenigen gedacht, die das Programm bauen oder den Quellcode verändern wollen!</p>
					
					<p>Allen anderen BenutzerInnen hilft das <a href="#" class="link-handbuch">Handbuch</a> vielleicht eher weiter.</p>
				</section>
				
				<!-- SUCHE -->
				<section id="sektion-suche">
					<h2>Suchergebnisse</h2>
					
					<div id="suchergebnisse"></div>
				</section>
				
				<!-- TECHNIK -->
				<section id="sektion-framework" class="suche">
					<!-- Electron -->
					<h2 id="framework-electron"><i>Electron</i>-Framework</h2>
					
					<p><i class="app-name"></i> läuft auf dem <a href="https://electronjs.org/"><i>Electron</i></a>-Framework. <i>Electron</i> ist eine Kombination aus <a href="https://www.chromium.org/Home"><i>Chromium</i></a>, dem Open-Source-Browser, auf dem <i>Google Chrome</i> basiert, und <a href="https://nodejs.org/"><i>Node.js</i></a>, einer JavaScript-Laufzeitumgebung mit der Implementierung <i>V8</i>. Das Framework kann komplett via JavaScript gesteuert werden, weswegen zum Programmieren der App Kenntnisse in den Sprachen <abbr title="Hyptertext Markup Language" lang="en">HTML</abbr>, <abbr title="Cascading Style Sheets" lang="en">CSS</abbr> und JavaScript vollkommen ausreichen.</p>
					
					<p><i>Electron</i> übernimmt die schwierigen Aufgaben, die sich beim Programmieren einer Desktop-App stellen. Es kümmert sich um die Integration in das Betriebssystem, ermöglicht also lesende und schreibende Dateizugriffe sowie das Öffnen externer Programme, erzeugt die Dateidialoge zum Öffnen und Speichern der Karteien und verwaltet über den betriebssystemeigenen Fenster-Manager die einzelnen Programm-Fenster, in denen eine leicht eingedampfte Variante des <i>Chromium</i>-Browsers für die Anzeige zuständig ist. Jedes Programm-Fenster läuft in einem eigenen Renderer-Prozess, weswegen die einzelnen Fenster nicht direkt miteiander kommunizieren können. Das Öffnen der Programm-Fenster und die Darstellung der Fenster-Menüs werden im Wesentlichten über den Main-Prozess gesteuert, über den die App initialisiert wird. Dieser wiederum kann mit allen Fenstern kommunizieren.</p>
					
					<p>Der Main-Prozess wird über die Scripts in der Datei <span class="datei">./main.js</span> im Wurzelverzeichnis der App gesteuert (das Wurzelverzeichnis der App wird im Folgenden immer durch <span class="datei">./</span> bezeichnet). Vermittelt über diesen Prozess können die Fenster miteinander in Kommunikation treten. Über das Objekt <code class="quelltext">ipcMain</code> hört der Main-Prozess auf Meldungen der Renderer-Prozesse, die diese via <code class="quelltext">ipcRenderer</code> abgeschickt haben (<abbr title="vergleiche">vgl.</abbr> den Code in <span class="datei">./main.js</span> und <span class="datei">./js/app/init-app.js</span>).</p>
					
					<p>Daneben erleichtert <i>Electron</i> das <a href="#framework-paketieren">Paketieren der App</a> für die Betriebssysteme <i>Linux</i>, <i>Windows</i> und <i>macOS</i> enorm. Aus der paketierten App lassen sich im Anschluss die verschiedensten <a href="#framework-installer">Installer</a> für die einzelnen Betriebssysteme bauen.</p>
					
					<!-- Installation -->
					<h2 id="framework-installation">Installation von <i>Electron</i></h2>
					
					<p>Im Folgenden wird die Einrichtung von <i>Electron</i> auf einer <i>Linux</i>-Distribution beschrieben, die auf <a href="https://www.ubuntu.com/"><i>Ubuntu</i></a> basiert. Die Anweisungen dürften aber für alle Betriebssystem ähnlich sein, denn auch unter Windows wird <i>Node.js</i> <abbr title="beispielsweise">bspw.</abbr> über die Eingabeaufforderung gesteuert.</p>
					
					<p>Zunächst muss <i>Node.js</i> mit seinem Paketmanager <code>npm</code> installiert werden (für <i>Windows</i> gibt es <a href="https://nodejs.org/en/download/">eigene Installer</a>):</p>
					
					<pre>sudo apt-get install nodejs</pre>
					
					<p>Über die Eingaben <code>node -v</code> und <code>npm -v</code> bekommt man die Versionsnummern von <i>Node.js</i> <abbr title="beziehungsweise">bzw.</abbr> dessen Paketmanager angezeigt – ein einfacher Test, ob die Installation geklappt hat. Im Falle des Paketmanagers könnte ein Update ratsam sein:</p>
					
					<pre>sudo npm install -g npm@latest</pre>
					
					<p>Global lassen sich Programme aus dem <i>Node.js</i>-Respository (wie <abbr title="zum Beispiel">z. B.</abbr> das überaus hilfreiche <a href="https://jshint.com/">JSHint</a>) mithilfe des Schalters <code>-g</code> und Rootrechten (hier erlangt via <code>sudo</code>) installieren:</p>
					
					<pre>sudo npm install -g [PROGRAMM]</pre>
					
					<p><i>Electron</i> sollte allerdings nicht global, sondern lokal, <abbr title="das heißt">d. h.</abbr> im App-Ordern, installiert werden, sonst gibt es bei der späteren Paketierung mitunter Probleme – so zumindest meine Erfahrung. Das Zeichen für den aktuellen Pfad (<span class="datei">./</span>) steht hier und im Folgenden für das Wurzelverzeichnis der App, in dem <abbr title="unter anderem">u. a.</abbr> die Datei <span class="datei">./package.json</span> liegt. Die Installation ist simpel:</p>
					
					<pre>cd ./
npm install --save-dev electron</pre>
					
					<p>Während der Installation werden der Ordner <span class="datei">./node_modules/</span> und die Datei <span class="datei">./package-lock.json</span> erstellt. Der Ordner <span class="datei">./node_modules/</span> kann mehrere Hundert Megabyte groß sein!</p>
					
					<p>Da im Herzen von <i>Electron</i> ein Browser schlägt und Browser fortwährend mit Sicherheitsupdates versorgt werden wollen, gibt es sehr häufig (alle ein bis zwei Wochen) <a href="https://electronjs.org/releases/stable"><i>Electron</i>-Updates</a>. Das Update funktioniert genauso wie die Erstinstallation:</p>
					
					<pre>npm install --save-dev electron</pre>
					
					<p>Welche <i>Electron</i>-Version im App-Ordner installiert ist, kann man dem Fenster <a href="#" class="ueber-electron"><i>Über Electron</i></a> (auch aufzurufen über das Menü <i>Hilfe</i> im Hauptfenster von <i class="app-name"></i>) oder der <span class="datei">./package.json</span> entnehmen:</p>
					
					<pre class="quelltext">"devDependencies": {
	"electron": "^4.1.4",
	...
}</pre>
					
					<p>Über die aktuelle Version im <i>Node.js</i>-Respository gibt der Paketmanager Auskunft:</p>
					
					<pre>npm show electron version</pre>
					
					<p>Die stabile Version von <i>Electron</i> liefert nie die jüngste Ausgabe von <i>Chromium</i>. Technisch ist der Browser somit zwar immer leicht veraltet, um die notwendigen Sicherheitsupdates kümmert sich das <i>Electron</i>-Team aber fortwährend.</p>
					
					<p>Die <abbr title="Application Programming Interface" lang="en">API</abbr> von <i>Electron</i> ist sehr gut <a href="https://electronjs.org/docs">dokumentiert</a>; das Framework-Motto <q lang="en">It’s easier than you think</q>, somit gar nicht falsch. Für einen raschen Einstieg empfiehlt sich das zweiteilige, sehr übersichtliche <a href="https://electronjs.org/docs/tutorial/quick-start">Quick-Start-Tutorial</a>.</p>
					
					<!-- Starten -->
					<h2 id="framework-starten">Starten der App</h2>
					
					<p>Wie die App gestartet werden soll, wird in der Datei <span class="datei">./package.json</span> festgelegt. Die <span class="datei">./package.json</span> enthält neben Meta-Informationen zu Programm, Autor und Lizenz nämlich auch Scripts zum Starten und Paketieren von <i class="app-name"></i>. Die folgende Zeile legt fest, über welche Script-Datei der Main-Prozess initialisiert wird:</p>
					
					<pre class="quelltext">"main": "main.js",</pre>
					
					<p>Unter <code class="quelltext">"scripts"</code> steht <abbr title="unter anderem">u. a.</abbr> die Information, wie das Programm gestartet werden soll:</p>
					
					<pre class="quelltext">"scripts": {
	"start": "electron .",
	...
}</pre>
					
					<p>Für den Start der App ist bereits alles eingerichtet. Nach der Installation von <i>Electron</i> muss man im Programmordner nur noch den folgenden Befehl ausführen:</p>
					
					<pre>npm start</pre>
					
					<p>Nun sollte <i class="app-name"></i> im Entwickler-Modus gestartet werden. <abbr title="Das heißt">D. h.</abbr> konkret, dass sich über das Tastaturkürzel <kbd>Strg</kbd> + <kbd>⇧</kbd> + <kbd>I</kbd> die <i lang="en">Developer Tools</i> von <i>Chromium</i> öffnen lassen, die in der paketierten Version nicht mehr aufgerufen werden können. Außerdem erscheint im Hauptfenster das Menü <i>Dev</i>, das nach der Paketierung verschwunden ist.</p>
					
					<!-- Paketieren -->
					<h2 id="framework-paketieren">Paketieren der App</h2>
					
					<p>Das Paketieren von <i class="app-name"></i> ist denkbar einfach. Zunächst muss der <a href="https://github.com/electron-userland/electron-packager/">Packager von <i>Electron</i></a> installiert werden:</p>
					
					<pre>./
npm install --save-dev electron-packager</pre>

					<p>Der Packager wird – natürlich – über die Kommandozeile bedient:</p>
					
					<pre>electron-packager . zettelstraum [OPTIONEN]</pre>
					
					<p>Der <code>.</code> steht für das Quellverzeichnis und <code>zettelstraum</code> für den App-Namen. Über die zur Verfügung stehenden Optionen gibt die <a href="https://github.com/electron-userland/electron-packager/blob/master/docs/api.md"><abbr title="Application Programming Interface" lang="en">API</abbr></a>-Dokumentation des Packagers ausführlich Auskunft.</p>
					
					<p>Im Prinzip muss man sich mit dieser Dokumentation allerdings nicht weiter beschäftigen, da für das Paketieren bereits alles eingerichtet ist. In der <span class="datei">./package.json</span> sind die Kommandozeilen-Befehle im Abschnitt <code class="quelltext">"scripts"</code> für das Erstellen von <i>Linux-</i> und <i>Windows</i>-Paketen bereits eingetragen. Die Befehle gehen davon aus, dass sich oberhalb des Wurzelverzeichnisses der App ein Ordner namens <span class="datei">dist</span> befindet. Hier wird die paketierte App abgelegt. Die Option <code>--overwrite</code> sorgt dafür, dass alte Paketierungen im Ordner <span class="datei">../dist</span> vor dem erneuten Paketieren entfernt werden. Die Scripts können über die folgenden Befehle ausgeführt werden. Für <i>Linux</i>:</p>
					
					<pre>npm run package-linux</pre>
					
					<p>Und für <i>Windows</i>:</p>
					
					<pre>npm run package-win</pre>
					
					<p>Die vordefinierten Scripts erstellen Pakete für eine 64-Bit-Architektur. Dies kann natürlich nach Belieben angepasst werden. Wie, darüber gibt die <a href="https://github.com/electron-userland/electron-packager/blob/master/docs/api.md"><abbr title="Application Programming Interface" lang="en">API</abbr></a> des Packagers Auskunft.</p>
					
					<p>Im Ordner <span class="datei">../dist</span> befinden sich nun die Ordner <span class="datei">zettelstraum-linux-x64</span> <abbr title="beziehungsweise">bzw.</abbr> <span class="datei">zettelstraum-win32-x64</span>. In den Ordnern befinden sich wiederum die ausführbaren Dateien <span class="datei">zettelstraum</span> <abbr title="beziehungsweise">bzw.</abbr> <span class="datei">zettelstraum.exe</span>. Über diese kann das paketierte Programm ohne vorherige Installation gestartet werden.</p>
					
					<p>Auch wenn die ausführbare Programm-Datei um die 100 Megabyte groß ist – ohne die anderen Dateien, die sich im Paket-Ordner befinden, kann die App nicht gestartet werden. Soll sie auf ein anderes Betriebssystem kopiert werden, muss also immer der gesamte Ordner mit allen Dateien mitgenommen werden.</p>
					
					<!-- Installer -->
					<h2 id="framework-installer">Installer bauen</h2>
					
					<p>Das Bauen von Installern für die verschiedenen Betriebssysteme und Architekturen gestaltet sich bedeutend schwieriger als das Paketieren. Grundsätzlich muss die App erst einmal <a href="#framework-paketieren">paketiert</a> werden. Dann kann man eines der vielen <a href="https://github.com/electron-userland/electron-packager/#distributable-creators">zur Verfügung stehenden Programme</a> zum Generieren eines Installers verwenden, die auf der Projektseite des Packagers aufgelistet sind.</p>
					
					<p>Im Folgenden wird beschrieben, wie ein Squirrel-Installer mithilfe von <a href="https://github.com/electron/windows-installer">electron-winstaller</a> erstellt werden kann. Getestet wurde das Ganze nur auf einem <i>Ubuntu</i>-Derivat.</p>
					
					<p>Zunächst einmal muss das Helfer-Programm via <code>npm</code> installiert werden:</p>
					
					<pre>./
npm install --save-dev electron-winstaller</pre>

					<p>Damit das Programm funktioniert, müssen <a href="https://wiki.ubuntuusers.de/Wine/">Wine</a> und ein ganzer Haufen <a href="https://github.com/mono/mono">Mono</a>-Bibliotheken installiert werden:</p>
					
					<pre>sudo apt-get install wine mono-runtime mono-devel</pre>
					
					<p>Wenn nach dem <a href="#framework-paketieren">Paketieren der App</a> der Ordner <span class="datei">../dist/zettelstraum-win32-x64/</span> erstellt wurde, kann das mitgelieferte Installerscript ausgeführt werden, das sich im Wurzelverzeichnis der App befindet:</p>
					
					<pre>node installer-win.js</pre>

					<p>Kommen Fehlermeldungen… viel Spaß beim Beheben! Normalerweise sollte nach kurzer Zeit allerdings nur die Meldung <code>Installer erstellt!</code> erscheinen. Danach befindet sich in <span class="datei">../dist</span> der Ordner <span class="datei">installer-win</span> und darin die Datei <span class="datei">ZettelsTraum-*.exe</span> (anstelle des Asterisks steht die Versionsnummer). Die ausführbare Datei kann kopiert und auf Windows-Rechnern installiert werden. (Getestet wurde die Installation nur auf <i>Windows 10</i>.)</p>
					
					<!-- Ordner -->
					<h2 id="framework-ordner">Programm- und Konfigurationsordner</h2>
					
					<p>Für die Installation eines mit <a href="https://github.com/Squirrel/Squirrel.Windows">Squirrel.Windows</a> erstellten Installers werden keine Administratorrechte benötigt. Das Programm installiert sich nach Doppelklick im lokalen Benutzerordner: <span class="datei">C:\Users\[BENUTZERNAME]\AppData\Local\zettelstraum\</span>.</p>
					
					<p>Soll eine neuere Version installiert werden, muss man <i class="app-name"></i> nur beenden (<abbr title="zum Beispiel">z. B.</abbr> via <kbd>Strg</kbd> + <kbd>Q</kbd>), auf der Installer-Datei doppelklicken und das war’s.</p>
					
					<p>Deinstalliert werden kann das Programm wie jede andere App über die Systemsteuerung von <i>Windows</i>.</p>
					
					<p>Ob die App nun paketiert und installiert ist oder einfach via <code>npm start</code> aufgerufen wurde, das <i>Electron</i>-Framework erstellt automatisch einen Konfigurationsordner im Standard-Konfigurationsverzeichnis des Betriebssystems. Das ist unter <i>Linux</i>:</p>
					
					<p class="datei">$HOME/.config/<span class="app-name"></span>/</p>
					
					<p>Und unter <i>Windows 10</i>:</p>
					
					<p class="datei">C:\Users\[BENUTZERNAME]\AppData\Roaming\<span class="app-name"></span>\</p>
					
					<p>Die Dateien in dem Ordner werden alle von <i>Electron</i> verwaltet – bis auf die Datei <span class="datei">einstellungen.json</span>. Diese wird von der <span class="datei">./main.js</span> erstellt. In ihr werden die Einstellungen des Hauptfensters der App und die Größe und Position von einigen (aber nicht allen) Programm-Fenstern gespeichert. Welche Werte die App anlegt, lässt sich dem Objekt <code class="quelltext">optionen.data</code> in der Datei <span class="datei">./js/app/optionen.js</span> entnehmen. Die durch die Datei <span class="datei">./main.js</span> angelegten Werte finden sich <abbr title="ebenda">ebd.</abbr> im gleichnamigen Objekt <code class="quelltext">optionen.data</code>.</p>
					
					<!-- Quelltext -->
					<h2 id="framework-quelltext">Quelltext in der paketierten App</h2>
					
					<p>Durch die Option <code>--asar</code> wird der Quelltext beim <a href="#framework-paketieren">Paketieren</a> in einer Archivdatei abgelegt: <span class="datei">app.asar</span>. In den Paket-Ordnern <span class="datei">zettelstraum-linux-x64</span> <abbr title="beziehungsweise">bzw.</abbr> <span class="datei">zettelstraum-win32-x64</span> befindet sich die Datei im Unterordner <span class="datei">resources</span>. Nach der Installation eines <a href="#framework-installer">mit Squirrel.Windows erstellten Installers</a> wird die Datei im Programmordner abgelegt:</p>
					
					<p class="datei">C:\Users\[BENUTZERNAME]\AppData\Local\zettelstraum\app-[VERSIONSNUMMER]\resources\app.asar</p>
					
					<p><a href="https://github.com/electron/asar">Asar</a> ist das Archiv-Programm von <i>Electron</i>, das ähnlich wie <code>tar</code> funktioniert: Der Inhalt ist nicht komprimiert, es können aber beliebig viele Ordner und Dateien in einem einzigen Archiv zusammengefasst werden.</p>
					
					<p>Entpacken lässt sich das Archiv via:</p>
					
					<pre>npx asar extract app.asar [ZIELORDNER]</pre>
					
					<p>Das Archiv enthält den vollständigen Quelltext von <i class="app-name"></i>. Allein der Ordner <span class="datei">node_modules</span>, in dem sich noch einige leere Unterordner befinden können, und die Datei <span class="datei">package-lock.json</span> gehören nicht zum Programm. Sie wurden automatisch bei der <a href="#framework-installation">Installation von <i>Electron</i></a> erstellt.</p>
				</section>
				
				<!-- ORDNER UND DATEIEN -->
				<section id="sektion-ordner" class="suche">
					<p>Im Folgenden wird summarisch beschrieben, welche Ordner und Dateien sich im Quellcode befinden, um die Orientierung für den Einsteig ein wenig zu erleichtern.</p>
					
					<p>Der Ordner <span class="datei">./node_modules/</span> und die Datei <span class="datei">./package-lock.json</span> werden beim <a href="#framework-installation">Installieren von <i>Electron</i></a> angelegt. Sie gehören nicht im eigentlichen Sinne zum Quelltext des Programms.</p>
					
					<!-- Root -->
					<h2 class="datei" id="ordner-root">./</h2>
					
					<ul>
						<li><span class="datei">./index.html</span>: <abbr title="Hyptertext Markupt Language" lang="en">HTML</abbr>-Datei, die beim Öffnen des Hauptfensters geladen wird</li>
						<li><span class="datei">./installer-win.js</span>: Node-Script, das auf Basis der <a href="#framework-paketieren">paketierten App</a> einen <a href="#framework-installer">Squirrel-Installer erstellt</a></li>
						<li><span class="datei">./main.js</span>: Node-Script, das die App initialisiert, die Programm-Fenster lädt und verwaltet</li>
						<li><span class="datei">./package.json</span>: <abbr title="JavaScript Object Notation" lang="en">JSON</abbr>-Datei mit Meta-Informationen zu Programm, Autor und Lizenz sowie Angaben darüber, wie die App gestartet wird; <abbr title="siehe">s.</abbr> <a href="#framework-starten">Framework &gt; Starten der App</a></li>
					</ul>
					
					<!-- CSS -->
					<h2 class="datei" id="ordner-css">./css/</h2>
					
					<p>Der Ordner enthält die Stylesheets aller Fenster.</p>
					
					<ul>
						<li><span class="datei">./css/*.css</span>: Stylesheets, die in mehr als einem Fenster benötigt werden und durch <code class="quelltext">@include</code> in andere Stylesheets eingebunden werden</li>
						<li><span class="datei">./css/app/*.css</span>: Stylesheets, die im Hauptfenster des Programms geladen werden; in der <span class="datei">app.css</span> finden sich viele basale Definitionen, die anderen Dateien regeln das Layout einzelner Teile oder Funktionen der App</li>
						<li><span class="datei">./css/win/*.css</span>: diese Stylesheets werden nur in den vom Hauptfenster abhängigen Nebenfenstern (also <abbr title="unter anderem">u. a.</abbr> dem Handbuch und diesem Fenster) benötigt</li>
					</ul>
					
					<!-- Fonts -->
					<h2 class="datei" id="ordner-fonts">./fonts/</h2>
					
					<p>Der Ordner enthält die Schriftarten, die durch die Datei <span class="datei">./css/fonts.css</span> geladen werden.</p>
					
					<!-- Images -->
					<h2 class="datei" id="ordner-img">./img/</h2>
					
					<ul>
						<li><span class="datei">./img/*.svg</span>: Vektorgrafiken, die sowohl für das Hauptfenster der App als auch für deren Nebenfenster genutzt werden; nicht alle Grafiken werden aus diesem Ordner geladen, mitunter sind sie als <abbr title="Extensible Markup Language">XML</abbr> direkt in den Quelltext der <abbr title="Hyptertext Markup Language">HTML</abbr>-Dateien eingefügt worden</li>
						<li><span class="datei">./img/file-type/*.png</span>: Bilddateien, die in den Betriebssystemen für die Assoziation mit <a href="#" class="link-sektion-wgd"><abbr title="Wortgeschichte digital">WGD</abbr>-Dateien</a> genutzt werden können; es gibt auch eine <abbr title="Scalable Vector Graphics">SVG</abbr>-Version dieser Bilder: <span class="datei">./img/datei-wgd.svg</span></li>
						<li><span class="datei">./img/icon/</span>: Bilddateien mit dem Programm-Icon in verschiedenen Größen für unterschiedliche Betriebssysteme; für <i>Windows</i> gibt es eine <span class="datei">icon.ico</span>, für <i>macOS</i> eine <span class="datei">icon.icns</span> und für <i>Linux</i> einen Ordner mit <span class="datei">*.png</span>-Dateien</li>
						<li><span class="datei">./img/menu/*.png</span>: Bilddateien, die nur von den Menüs verwendet werden, die das Framework verwaltet; dazu zählen das App-Menü am oberen Rand des Hauptfensters und die Kontextmenüs, die auf Rechtsklick erscheinen</li>
					</ul>
					
					<!-- JavaScript -->
					<h2 class="datei" id="ordner-js">./js/</h2>
					
					<p>Der Ordner enthält alle JavaScript-Dateien, die von den Renderer-Prozessen geladen werden. Im Unterordner <span class="datei">./js/app/</span> liegen Dateien, die (fast) ausschließlich vom Hauptfenster benutzt und in <span class="datei">./js/win/</span> Dateien, die ausschließlich von den Nebenfenstern geladen werden.</p>
					
					<p>Jede Datei enthält ein Objekt, das denselben Namen wie die Datei trägt (<a href="#" class="link-sektion-js">es gibt Ausnahmen</a>). Der Name weist darauf hin, welche Funktionalität die Scripts in der Datei steuern.</p>
					
					<!-- Licenses -->
					<h2 class="datei" id="ordner-licenses">./licenses/</h2>
					
					<p>Der Ordner enthält Plaintext-Dateien mit den Lizenzbedingungen zu den einzelnen Programmteilen.</p>
					
					<!-- Fenster -->
					<h2 class="datei" id="ordner-win">./win/</h2>
					
					<p>Der Ordner enthält die <abbr title="Hypertext Markup Language">HTML</abbr>-Dateien, die von den Nebenfenstern geladen werden.</p>
				</section>
				
				<!-- JAVASCRIPT -->
				<section id="sektion-js" class="suche">
					<h2 id="js-code">Der Code</h2>
					
					<p>Der JavaScript-Code ist <i lang="en">vanilla</i>. Sprich: Es wurden keine Bibliotheken wie <i>jQuery</i> oder dergleichen verwendet. Programmiert wurde im <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode"><i lang="en">strict mode</i></a>, einer restringierten Variante von JavaScript, die <abbr title="zum Beispiel">z. B.</abbr> Zuweisungsoperationen zu nicht deklarierten Variablen unmöglicht macht und vieles mehr unterbindet, was potenziell gefährlich oder einfach schlechter Stil ist.</p>
					
					<p>Der Code wurde extensiv kommentiert. Im Ergebnis sollte immer nachvollziehbar sein, welche Aufgabe das Script an der jeweiligen Stelle erfüllt. So wird <abbr title="zum Beispiel">z. B.</abbr> bei jeder Funktion angegeben, wozu sie dient und welchen Variablentyp die Argumente haben.</p>
					
					<p>Alle Funktionen stecken in Objekten, um den Namensraum des Fensters nicht zu vermüllen. Dabei steht in jeder JavaScript-Datei ein Objekt, das exakt denselben Namen wie die Datei trägt. Sucht man also die Methode <code class="quelltext">popup.oeffnen()</code> oder die Eigenschaft <code class="quelltext">popup.belegID</code> muss man nur nach der Datei <span class="datei">popup.js</span> Ausschau halten. Eine Ausnahme von diesem Schema bilden allein die Scripts im Wurzelverzeichnis und Dateien mit dem Namensmuster <span class="datei">init-*.js</span>. In letzteren werden Eventobjekte des Fensters initialisiert, zu dem die jeweilige Datei gehört. Das betreffende Fenster lässt sich leicht aus dem Dateinamen ableiten.</p>
					
					<p><abbr title="Vergleiche">Vgl.</abbr> zu den JavaScript-Dateien auch die Anmerkungen im Kapitel <a href="#ordner-js">Ordner und Dateien</a>
					
					<h2 id="js-integration">Integration von <i>Electron</i> und <i>Node.js</i></h2>
					
					<p>Eine Besonderheit des JavaScript-Codes ist, dass auf Objekte, Methoden und Eigenschaften von <i>Electron</i> und <i>Node.js</i> auch in den Renderer-Prozessen zurückgegriffen wird. Hierzu wird die in JavaScript sonst nicht vorhandene Methode <code class="quelltext">require()</code> benutzt.</p>
					
					<p>Über <code class="quelltext">const {app} = require("electron").remote</code> <abbr title="zum Beispiel">z. B.</abbr> wird der Zugriff auf das App-Objekt im Main-Prozess ermöglicht. Und via <code class="quelltext">const path = require("path")</code> kann man das Node-Modul <a href="https://nodejs.org/api/path.html"><i>Path</i></a> laden, um sich neben vielem anderen <abbr title="zum Beispiel">z. B.</abbr> Informationen über den <i lang="en">path segment separator</i> im aktuellen Betriebssystem geben zu lassen (nämlich via <code class="quelltext">path.sep</code>).</p>
				</section>
				
				<!-- WGD-DATEIFORMAT -->
				<section id="sektion-wgd" class="suche">
					<p>Die <abbr title="Wortgeschichte digital">WGD</abbr>-Dateien sind im <abbr title="JavaScript Object Notation">JSON</abbr>-Format.</p>
					
					<p>Nach dem Laden einer <abbr title="Wortgeschichte digital">WGD</abbr>-Datei in <i class="app-name"></i> befinden sich die Daten im globalen Objekt <code class="quelltext">data</code>. Ihre Werte lassen sich dann in allen Funktionen des Hauptfensters durch einfache Statements wie <code class="quelltext">data.dc</code> lesen oder schreiben.</p>
					
					<p>Alle Dateien sind gleich aufgebaut (<span class="obacht">Datenformat Version 2</span>):</p>
					
					<table>
						<tr>
							<th>Schlüssel</th>
							<th>Datentyp</th>
							<th>Format</th>
							<th>Funktion</th>
						</tr>
						<tr>
							<td><code class="quelltext">an</code></td>
							<td class="datentyp">Array</td>
							<td>eindimensional,<br>mit <span class="datentyp">Strings</span> gefüllt</td>
							<td>Anhänge; Pfade zu Dateien, die an die Kartei angehängt wurden; die Pfade können absolut oder relativ zum Speicherort der Kartei sein</td>
						</tr>
						<tr>
							<td><code class="quelltext">bd</code></td>
							<td class="datentyp">Object</td>
							<td> </td>
							<td>reserviert für die Bedeutungen-Funktion</td>
						</tr>
						<tr>
							<td><code class="quelltext">be</code></td>
							<td class="datentyp">Array</td>
							<td>eindimensional,<br>mit <span class="datentyp">Strings</span> gefüllt</td>
							<td>BearbeiterInnen, die die Kartei geändert haben</td>
						</tr>
						<tr>
							<td><code class="quelltext">dc</code></td>
							<td class="datentyp">String</td>
							<td>ISO-8601-Datum:<br><code class="quelltext">"2001-11-01<br>T11:22:33.444Z"</code></td>
							<td>Zeitpunkt, zu dem die Kartei erstellt wurde</td>
						</tr>
						<tr>
							<td><code class="quelltext">dm</code></td>
							<td class="datentyp">String</td>
							<td>ISO-8601-Datum:<br><code class="quelltext">"2001-11-01<br>T11:22:33.444Z"</code></td>
							<td>Zeitpunkt, zu dem die Kartei zuletzt gespeichert wurde</td>
						</tr>
						<tr>
							<td><code class="quelltext">fv</code></td>
							<td class="datentyp">Array</td>
							<td>eindimensional,<br>mit <span class="datentyp">Objects</span> gefüllt</td>
							<td>Formvarianten zum Wort der Kartei, die aus dem <abbr title="Deutschen Textarchiv">DTA</abbr> geladen und/oder manuell eingegeben wurden</td>
						</tr>
						<tr class="wgd-ebene1">
							<td colspan="4"><p>Die <span class="datentyp">Objects</span> in den Slots haben die folgenden Schlüssel und Werte:</p></td>
						</tr>
						<tr class="wgd-ebene1">
							<td><p><code class="quelltext">va</code></p></td>
							<td class="datentyp">String</td>
							<td> </td>
							<td>Formvariante</td>
						</tr>
						<tr class="wgd-ebene1">
							<td><p><code class="quelltext">qu</code></p></td>
							<td class="datentyp">String</td>
							<td><code class="quelltext">"dta"</code> oder <code class="quelltext">"zt"</code></td>
							<td>Quelle der Formvariante; mit <code class="quelltext">"zt"</code> markierte Varianten wurden manuell ergänzt</td>
						</tr>
						<tr>
							<td><code class="quelltext">ha</code></td>
							<td class="datentyp">Object</td>
							<td> </td>
							<td>reserviert für die Kartenhaufen-Funktion</td>
						</tr>
						<tr>
							<td><code class="quelltext">ka</code></td>
							<td class="datentyp">Object</td>
							<td> </td>
							<td>Karteikarten</td>
						</tr>
						<tr class="wgd-ebene1">
							<td colspan="4"><p>Es folgen beliebig viele <span class="datentyp">Objects</span> mit einmaligen Schlüsseln:</p></td>
						</tr>
						<tr class="wgd-ebene1">
							<td><p>(ID)</p></td>
							<td class="datentyp">Object</td>
							<td><code class="quelltext">/[0-9]+/</code></td>
							<td>Karteikarte</td>
						</tr>
						<tr class="wgd-ebene2">
							<td colspan="4"><p>In jedem <span class="datentyp">Object</span> die folgenden Schlüssel und Werte:</p></td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">an</code></p></td>
							<td class="datentyp">Array</td>
							<td>eindimensional,<br>mit <span class="datentyp">Strings</span> gefüllt</td>
							<td>Anhänge; Pfade zu Dateien, die an die Karteikarte angehängt wurden; die Pfade können absolut oder relativ zum Speicherort der Kartei sein</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">au</code></p></td>
							<td class="datentyp">String</td>
							<td> </td>
							<td>Autor des Belegs</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">bc</code></p></td>
							<td class="datentyp">Boolean</td>
							<td> </td>
							<td>Buchung (Beleg wurde im Artikel zitiert)</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">bd</code></p></td>
							<td class="datentyp">String</td>
							<td><code class="quelltext">\n</code> möglich</td>
							<td>Bedeutung; mehrere Bedeutungen durch <code class="quelltext">\n</code> voneinander getrennt; neue Hierarchie beginnt mit <code class="quelltext">": "</code></td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">be</code></p></td>
							<td class="datentyp">Number</td>
							<td>0–5</td>
							<td>Markierung mit Sternen; <code class="quelltext">0</code> = unmarkiert, <code class="quelltext">5</code> = 5 Sterne</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">bs</code></p></td>
							<td class="datentyp">String</td>
							<td><code class="quelltext">\n</code> möglich</td>
							<td>Belegtext; kann <abbr title="Hyptertext Markup Language">HTML</abbr>-Tags enthalten</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">bu</code></p></td>
							<td class="datentyp">Boolean</td>
							<td> </td>
							<td>Bücherdienst (Beleg muss am Original überprüft werden)</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">da</code></p></td>
							<td class="datentyp">String</td>
							<td> </td>
							<td>Belegdatum; Freitext, enthalten sein muss aber zwingend <code class="quelltext">/[0-9]{4}/</code> und/oder <code class="quelltext">/[0-9]{2}\. Jh\./</code></td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">dc</code></p></td>
							<td class="datentyp">String</td>
							<td>ISO-8601-Datum:<br><code class="quelltext">"2001-11-01<br>T11:22:33.444Z"</code></td>
							<td>Zeitpunkt, zu dem die Karteikarte erstellt wurde</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">dm</code></p></td>
							<td class="datentyp">String</td>
							<td>ISO-8601-Datum:<br><code class="quelltext">"2001-11-01<br>T11:22:33.444Z"</code></td>
							<td>Zeitpunkt, zu dem die Karteikarte zuletzt gespeichert wurde</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">ko</code></p></td>
							<td class="datentyp">Boolean</td>
							<td> </td>
							<td>Kontext (der Kontext des Belegs ist zu dürftig und muss am Original begutachtet werden)</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">kr</code></p></td>
							<td class="datentyp">String</td>
							<td> </td>
							<td>Korpus, aus dem der Beleg stammt;<br><span class="obacht">mit Version 2 ergänzt</span></td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">no</code></p></td>
							<td class="datentyp">String</td>
							<td><code class="quelltext">\n</code> möglich</td>
							<td>Notizen</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">ts</code></p></td>
							<td class="datentyp">String</td>
							<td><code class="quelltext">\n</code> möglich</td>
							<td>Textsorte; mehrere Textsorten durch <code class="quelltext">\n</code> voneinander getrennt; neue Hierarchie beginnt mit <code class="quelltext">": "</code></td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">un</code></p></td>
							<td class="datentyp">Boolean</td>
							<td> </td>
							<td>Beleg unvollständig (muss weiter bearbeitet werden)</td>
						</tr>
						<tr class="wgd-ebene2">
							<td><p><code class="quelltext">qu</code></p></td>
							<td class="datentyp">String</td>
							<td><code class="quelltext">\n</code> möglich</td>
							<td>Quellenangabe</td>
						</tr>
						<tr>
							<td><p><code class="quelltext">le</code></p></td>
							<td class="datentyp">Array</td>
							<td>eindimensional,<br>mit <span class="datentyp">Strings</span> gefüllt</td>
							<td>Lexika, die überprüft wurden</td>
						</tr>
						<tr>
							<td><p><code class="quelltext">no</code></p></td>
							<td class="datentyp">String</td>
							<td><code class="quelltext">\n</code> möglich</td>
							<td>Notizen</td>
						</tr>
						<tr>
							<td><p><code class="quelltext">rd</code></p></td>
							<td class="datentyp">Array</td>
							<td>eindimensional,<br>mit <span class="datentyp">Objects</span> gefüllt</td>
							<td>Redaktionsereignisse</td>
						</tr>
						<tr class="wgd-ebene1">
							<td colspan="4"><p>Die <span class="datentyp">Objects</span> in den Slots haben die folgenden Schlüssel und Werte:</p></td>
						</tr>
						<tr class="wgd-ebene1">
							<td><p><code class="quelltext">da</code></p></td>
							<td class="datentyp">String</td>
							<td>ISO-8601-Datum:<br><code class="quelltext">"2019-12-01"</code></td>
							<td>Tagesdatum des Ereignisses</td>
						</tr>
						<tr class="wgd-ebene1">
							<td><p><code class="quelltext">er</code></p></td>
							<td class="datentyp">String</td>
							<td> </td>
							<td>Redaktionsereignis</td>
						</tr>
						<tr class="wgd-ebene1">
							<td><p><code class="quelltext">pr</code></p></td>
							<td class="datentyp">String</td>
							<td> </td>
							<td>BearbeiterIn</td>
						</tr>
						<tr>
							<td><p><code class="quelltext">re</code></p></td>
							<td class="datentyp">Number</td>
							<td><code class="quelltext">/[0-9]+/</code></td>
							<td>Revisionsnummer; wird bei jedem Speichern der Kartei um <code class="quelltext">1</code> hochgezählt</td>
						</tr>
						<tr>
							<td><p><code class="quelltext">ty</code></p></td>
							<td class="datentyp">String</td>
							<td>immer <code class="quelltext">"wgd"</code></td>
							<td>Dateityp; für Tests beim Öffnen einer Kartei, damit nicht beliebige <abbr title="JavaScript Object Notation">JSON</abbr>-Daten in einem anderen Dateiformat geladen werden</td>
						</tr>
						<tr>
							<td><p><code class="quelltext">ve</code></p></td>
							<td class="datentyp">Number</td>
							<td><code class="quelltext">/[0-9]+/</code></td>
							<td>Versionsnummer des <abbr title="Wortgeschichte digital">WGD</abbr>-Dateiformats</td>
						</tr>
						<tr>
							<td><p><code class="quelltext">wo</code></p></td>
							<td class="datentyp">String</td>
							<td> </td>
							<td>Wort, zu dem die Kartei erstellt wurde</td>
						</tr>
					</table>
				</section>
			</div>
		</main>
	</body>
</html>
